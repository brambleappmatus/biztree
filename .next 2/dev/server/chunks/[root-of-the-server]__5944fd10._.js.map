{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///Users/matusstano/Desktop/biztree/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\nconst prismaClientSingleton = () => {\n    return new PrismaClient();\n};\n\ndeclare global {\n    var prisma: undefined | ReturnType<typeof prismaClientSingleton>;\n}\n\nconst prisma = globalThis.prisma ?? prismaClientSingleton();\n\nexport default prisma;\n\nif (process.env.NODE_ENV !== \"production\") globalThis.prisma = prisma;\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,wBAAwB;IAC1B,OAAO,IAAI,6IAAY;AAC3B;AAMA,MAAM,SAAS,WAAW,MAAM,IAAI;uCAErB;AAEf,wCAA2C,WAAW,MAAM,GAAG"}},
    {"offset": {"line": 128, "column": 0}, "map": {"version":3,"sources":["file:///Users/matusstano/Desktop/biztree/src/lib/auth.ts"],"sourcesContent":["import type { NextAuthOptions } from \"next-auth\";\nimport CredentialsProvider from \"next-auth/providers/credentials\";\nimport { PrismaAdapter } from \"@next-auth/prisma-adapter\";\nimport prisma from \"@/lib/prisma\";\nimport bcrypt from \"bcryptjs\";\n\nimport GoogleProvider from \"next-auth/providers/google\";\nimport AppleProvider from \"next-auth/providers/apple\";\n\nexport const authOptions: NextAuthOptions = {\n    debug: true, // Enable debugging to see why sign-in fails\n    adapter: PrismaAdapter(prisma),\n    providers: [\n        GoogleProvider({\n            clientId: process.env.GOOGLE_CLIENT_ID!,\n            clientSecret: process.env.GOOGLE_CLIENT_SECRET!,\n            allowDangerousEmailAccountLinking: true,\n        }),\n        AppleProvider({\n            clientId: process.env.APPLE_ID!,\n            clientSecret: process.env.APPLE_SECRET!,\n            allowDangerousEmailAccountLinking: true,\n        }),\n        CredentialsProvider({\n            name: \"credentials\",\n            credentials: {\n                email: { label: \"Email\", type: \"email\" },\n                password: { label: \"Password\", type: \"password\" }\n            },\n            async authorize(credentials) {\n                if (!credentials?.email || !credentials?.password) {\n                    return null;\n                }\n\n                const user = await prisma.user.findUnique({\n                    where: { email: credentials.email }\n                });\n\n                if (!user || !user.password) {\n                    return null;\n                }\n\n                const isPasswordValid = await bcrypt.compare(\n                    credentials.password,\n                    user.password\n                );\n\n                if (!isPasswordValid) {\n                    return null;\n                }\n\n                return {\n                    id: user.id,\n                    email: user.email,\n                    role: user.role,\n                    onboardingCompleted: user.onboardingCompleted\n                };\n            }\n        })\n    ],\n    session: {\n        strategy: \"jwt\"\n    },\n    pages: {\n        signIn: \"/login\",\n    },\n    callbacks: {\n        async signIn({ user, account, profile }) {\n            if (account?.provider === \"google\" || account?.provider === \"apple\") {\n                console.log(`üîê ${account.provider} Sign In Attempt:`, {\n                    userEmail: user.email,\n                    accountProvider: account.provider,\n                    profileEmail: profile?.email\n                });\n\n                // Check if user exists with this email\n                const existingUser = await prisma.user.findUnique({\n                    where: { email: user.email! },\n                    include: { accounts: true }\n                });\n\n                if (existingUser) {\n                    // Check if this OAuth provider is already linked\n                    const isLinked = existingUser.accounts.some(\n                        acc => acc.provider === account.provider\n                    );\n\n                    if (!isLinked) {\n                        // Link the account\n                        console.log(\"üîó Linking OAuth account to existing user\");\n                        await prisma.account.create({\n                            data: {\n                                userId: existingUser.id,\n                                type: account.type,\n                                provider: account.provider,\n                                providerAccountId: account.providerAccountId,\n                                refresh_token: account.refresh_token,\n                                access_token: account.access_token,\n                                expires_at: account.expires_at,\n                                token_type: account.token_type,\n                                scope: account.scope,\n                                id_token: account.id_token,\n                                session_state: account.session_state,\n                            }\n                        });\n                    }\n                }\n            }\n            return true;\n        },\n        async jwt({ token, user }) {\n            if (user) {\n                token.role = (user as any).role;\n                token.onboardingCompleted = (user as any).onboardingCompleted;\n            }\n            return token;\n        },\n        async session({ session, token }) {\n            if (session.user) {\n                (session.user as any).id = token.sub!;\n                (session.user as any).role = token.role as string;\n                (session.user as any).onboardingCompleted = token.onboardingCompleted as boolean;\n            }\n            return session;\n        }\n    },\n    events: {\n        async createUser({ user }) {\n            console.log(\"üë§ User Created:\", user);\n\n            // Send welcome email for new users (including OAuth users)\n            try {\n                const { Resend } = await import(\"resend\");\n                const { WelcomeEmail } = await import(\"@/components/emails/WelcomeEmail\");\n\n                const resend = new Resend(process.env.RESEND_API_KEY);\n\n                await resend.emails.send({\n                    from: 'BizTree <no-reply@biztree.bio>',\n                    to: user.email!,\n                    subject: 'Vitajte v BizTree!',\n                    react: WelcomeEmail({\n                        name: user.name || user.email!.split('@')[0]\n                    }) as React.ReactNode,\n                });\n\n                console.log(\"‚úÖ Welcome email sent to:\", user.email);\n            } catch (emailError) {\n                console.error(\"‚ùå Failed to send welcome email:\", emailError);\n                // Don't fail user creation if email fails\n            }\n        },\n        async linkAccount({ user, account }) {\n            console.log(\"üîó Account Linked:\", { userId: user.id, provider: account.provider });\n        },\n        async signIn({ user, account, isNewUser }) {\n            console.log(\"‚úÖ Sign In Successful:\", { userId: user.id, isNewUser, provider: account?.provider });\n        }\n    },\n    secret: process.env.NEXTAUTH_SECRET,\n};\n\nexport async function hashPassword(password: string): Promise<string> {\n    return bcrypt.hash(password, 12);\n}\n\nexport async function verifyPassword(password: string, hashedPassword: string): Promise<boolean> {\n    return bcrypt.compare(password, hashedPassword);\n}\n\nexport function isSuperAdmin(session: any): boolean {\n    return session?.user?.role === \"SUPERADMIN\";\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 317, "column": 0}, "map": {"version":3,"sources":["file:///Users/matusstano/Desktop/biztree/src/lib/licensing.ts"],"sourcesContent":["\"use server\";\n\nimport prisma from \"@/lib/prisma\";\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth\";\n\n/**\n * Check if a subscription is expired and handle auto-downgrade\n */\nasync function checkAndHandleExpiration(profileId: string): Promise<void> {\n    const profile = await prisma.profile.findUnique({\n        where: { id: profileId },\n        select: {\n            id: true,\n            subscriptionExpiresAt: true,\n            subscriptionStatus: true,\n            tierId: true,\n            tier: { select: { name: true } }\n        }\n    });\n\n    if (!profile) return;\n\n    // Check if subscription is expired\n    const now = new Date();\n    if (profile.subscriptionExpiresAt && profile.subscriptionExpiresAt < now) {\n        // Only downgrade if not already on Free tier\n        if (profile.tier?.name !== \"Free\") {\n            // Get Free tier\n            const freeTier = await prisma.tier.findUnique({\n                where: { name: \"Free\" }\n            });\n\n            if (freeTier) {\n                // Update profile to Free tier\n                await prisma.profile.update({\n                    where: { id: profileId },\n                    data: {\n                        tierId: freeTier.id,\n                        subscriptionStatus: \"EXPIRED\",\n                        bgImage: \"dark-gray\" // Reset background on downgrade\n                    }\n                });\n\n                // Log the downgrade\n                await prisma.subscriptionHistory.create({\n                    data: {\n                        profileId,\n                        action: \"EXPIRED\",\n                        previousTierId: profile.tierId,\n                        newTierId: freeTier.id,\n                        performedBy: \"SYSTEM\",\n                        notes: \"Subscription expired and auto-downgraded to Free tier\"\n                    }\n                });\n            }\n        }\n    }\n}\n\n/**\n * Get the effective tier for a profile (considering expiration)\n */\nexport async function getEffectiveTier(profileId: string) {\n    await checkAndHandleExpiration(profileId);\n\n    const profile = await prisma.profile.findUnique({\n        where: { id: profileId },\n        include: {\n            tier: {\n                include: {\n                    features: {\n                        include: {\n                            feature: true\n                        }\n                    }\n                }\n            }\n        }\n    });\n\n    return profile?.tier || null;\n}\n\n/**\n * Server-side utility to check if a profile has access to a specific feature\n */\nexport async function hasFeatureAccess(profileId: string, featureKey: string): Promise<boolean> {\n    const tier = await getEffectiveTier(profileId);\n\n    if (!tier) {\n        // No tier assigned = no access to premium features\n        return false;\n    }\n\n    return tier.features.some(tf => tf.feature.key === featureKey);\n}\n\n/**\n * Get all features for a specific profile\n */\nexport async function getProfileFeatures(profileId: string): Promise<string[]> {\n    const tier = await getEffectiveTier(profileId);\n\n    if (!tier) {\n        return [];\n    }\n\n    return tier.features.map(tf => tf.feature.key);\n}\n\n/**\n * Get current user's profile features\n */\nexport async function getCurrentUserFeatures(): Promise<string[]> {\n    const session = await getServerSession(authOptions);\n\n    if (!session?.user?.id) {\n        return [];\n    }\n\n    const user = await prisma.user.findUnique({\n        where: { id: session.user.id },\n        include: {\n            profiles: {\n                select: { id: true }\n            }\n        }\n    });\n\n    if (!user || !user.profiles || user.profiles.length === 0) {\n        return [];\n    }\n\n    return getProfileFeatures(user.profiles[0].id);\n}\n\n/**\n * Validate a promo code\n */\nexport async function validatePromoCode(code: string, tierId?: string) {\n    const promoCode = await prisma.promoCode.findUnique({\n        where: { code: code.toUpperCase() }\n    });\n\n    if (!promoCode) {\n        return { valid: false, error: \"Promo code not found\" };\n    }\n\n    if (!promoCode.isActive) {\n        return { valid: false, error: \"Promo code is inactive\" };\n    }\n\n    const now = new Date();\n    if (promoCode.validFrom > now) {\n        return { valid: false, error: \"Promo code not yet valid\" };\n    }\n\n    if (promoCode.validUntil && promoCode.validUntil < now) {\n        return { valid: false, error: \"Promo code has expired\" };\n    }\n\n    if (promoCode.maxUses && promoCode.currentUses >= promoCode.maxUses) {\n        return { valid: false, error: \"Promo code usage limit reached\" };\n    }\n\n    // Check if applicable to the tier\n    if (tierId && promoCode.applicableTierIds.length > 0) {\n        if (!promoCode.applicableTierIds.includes(tierId)) {\n            return { valid: false, error: \"Promo code not applicable to this tier\" };\n        }\n    }\n\n    return {\n        valid: true,\n        promoCode: {\n            id: promoCode.id,\n            code: promoCode.code,\n            type: promoCode.type,\n            value: promoCode.value,\n            description: promoCode.description\n        }\n    };\n}\n\n/**\n * Apply a promo code to a profile (increment usage)\n */\nexport async function applyPromoCode(promoCodeId: string) {\n    await prisma.promoCode.update({\n        where: { id: promoCodeId },\n        data: {\n            currentUses: { increment: 1 }\n        }\n    });\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 543, "column": 0}, "map": {"version":3,"sources":["file:///Users/matusstano/Desktop/biztree/src/app/api/user/features/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport { getCurrentUserFeatures } from \"@/lib/licensing\";\n\nexport async function GET() {\n    try {\n        const features = await getCurrentUserFeatures();\n        return NextResponse.json({ features });\n    } catch (error) {\n        console.error(\"Failed to fetch user features:\", error);\n        return NextResponse.json({ features: [] }, { status: 500 });\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,eAAe;IAClB,IAAI;QACA,MAAM,WAAW,MAAM,IAAA,yKAAsB;QAC7C,OAAO,sKAAY,CAAC,IAAI,CAAC;YAAE;QAAS;IACxC,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,kCAAkC;QAChD,OAAO,sKAAY,CAAC,IAAI,CAAC;YAAE,UAAU,EAAE;QAAC,GAAG;YAAE,QAAQ;QAAI;IAC7D;AACJ"}}]
}