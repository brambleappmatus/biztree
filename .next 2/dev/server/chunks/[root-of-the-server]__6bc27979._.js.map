{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///Users/matusstano/Desktop/biztree/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\nconst prismaClientSingleton = () => {\n    return new PrismaClient();\n};\n\ndeclare global {\n    var prisma: undefined | ReturnType<typeof prismaClientSingleton>;\n}\n\nconst prisma = globalThis.prisma ?? prismaClientSingleton();\n\nexport default prisma;\n\nif (process.env.NODE_ENV !== \"production\") globalThis.prisma = prisma;\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,wBAAwB;IAC1B,OAAO,IAAI,6IAAY;AAC3B;AAMA,MAAM,SAAS,WAAW,MAAM,IAAI;uCAErB;AAEf,wCAA2C,WAAW,MAAM,GAAG"}},
    {"offset": {"line": 68, "column": 0}, "map": {"version":3,"sources":["file:///Users/matusstano/Desktop/biztree/src/app/api/analytics/time/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\nimport prisma from '@/lib/prisma'\n\nexport async function POST(request: NextRequest) {\n    try {\n        const body = await request.json()\n        const { profileId, visitorId, sessionId, path, timeSpent } = body\n\n        if (!profileId || !visitorId || !sessionId || timeSpent === undefined) {\n            return NextResponse.json(\n                { error: 'Missing required fields' },\n                { status: 400 }\n            )\n        }\n\n        // Find the most recent page view for this session and path\n        const pageView = await prisma.pageView.findFirst({\n            where: {\n                profileId,\n                visitorId,\n                sessionId,\n                path: path || '/',\n            },\n            orderBy: {\n                createdAt: 'desc',\n            },\n        })\n\n        if (pageView) {\n            // Update the time spent\n            await prisma.pageView.update({\n                where: { id: pageView.id },\n                data: { timeSpent },\n            })\n        }\n\n        return NextResponse.json({ success: true })\n    } catch (error) {\n        console.error('Analytics time tracking error:', error)\n        return NextResponse.json(\n            { error: 'Failed to track time' },\n            { status: 500 }\n        )\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,eAAe,KAAK,OAAoB;IAC3C,IAAI;QACA,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,IAAI,EAAE,SAAS,EAAE,GAAG;QAE7D,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC,aAAa,cAAc,WAAW;YACnE,OAAO,sKAAY,CAAC,IAAI,CACpB;gBAAE,OAAO;YAA0B,GACnC;gBAAE,QAAQ;YAAI;QAEtB;QAEA,2DAA2D;QAC3D,MAAM,WAAW,MAAM,uJAAM,CAAC,QAAQ,CAAC,SAAS,CAAC;YAC7C,OAAO;gBACH;gBACA;gBACA;gBACA,MAAM,QAAQ;YAClB;YACA,SAAS;gBACL,WAAW;YACf;QACJ;QAEA,IAAI,UAAU;YACV,wBAAwB;YACxB,MAAM,uJAAM,CAAC,QAAQ,CAAC,MAAM,CAAC;gBACzB,OAAO;oBAAE,IAAI,SAAS,EAAE;gBAAC;gBACzB,MAAM;oBAAE;gBAAU;YACtB;QACJ;QAEA,OAAO,sKAAY,CAAC,IAAI,CAAC;YAAE,SAAS;QAAK;IAC7C,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,kCAAkC;QAChD,OAAO,sKAAY,CAAC,IAAI,CACpB;YAAE,OAAO;QAAuB,GAChC;YAAE,QAAQ;QAAI;IAEtB;AACJ"}}]
}